# This workflow automatically generates runtime packages (apps without source code) for releases.
# 
# By default, it only processes releases from specific branches to avoid creating runtime packages
# for development or feature branch releases.
#
# Customize allowed branches:
#   Edit the $allowedBranches array in the "Determine Release Tag and Check Branch" step
#   Default: @('main', 'release/*')
#   Examples: 
#     - Only main: @('main')
#     - Main and releases: @('main', 'release/*', 'releases/*')
#     - All releases: @('release/*')
#     - All branches: @('*')
#
# Manual override:
#   When manually triggering this workflow, you can enable "Skip branch check" to process any release

name: 'Add Runtime Packages to Release'

on:
  release:
    types: [published]
  workflow_dispatch:
    inputs:
      release_tag:
        description: 'Release tag to add runtime packages to'
        required: true
        type: string
      skip_branch_check:
        description: 'Skip branch check (process any release)'
        required: false
        type: boolean
        default: false

permissions:
  contents: write
  actions: read

defaults:
  run:
    shell: powershell

env:
  ALGoOrgSettings: ${{ vars.ALGoOrgSettings }}
  ALGoRepoSettings: ${{ vars.ALGoRepoSettings }}

jobs:
  GenerateRuntimePackages:
    runs-on: windows-latest
    name: Generate and Upload Runtime Packages
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Read settings
        uses: microsoft/AL-Go-Actions/ReadSettings@v7.3
        with:
          shell: powershell
          get: repoVersion

      - name: Determine Release Tag and Check Branch
        id: release
        run: |
          # Determine tag and release ID
          if ('${{ github.event_name }}' -eq 'release') {
            $tag = '${{ github.event.release.tag_name }}'
            $releaseId = '${{ github.event.release.id }}'
            $targetCommitish = '${{ github.event.release.target_commitish }}'
          } else {
            $tag = '${{ github.event.inputs.release_tag }}'
            # Get release info from tag
            $releaseInfo = gh release view $tag --json id,targetCommitish | ConvertFrom-Json
            $releaseId = $releaseInfo.id
            $targetCommitish = $releaseInfo.targetCommitish
          }
          
          Write-Host "Release Tag: $tag"
          Write-Host "Release ID: $releaseId"
          Write-Host "Target Commitish: $targetCommitish"
          
          # Define allowed branches (customize this list as needed)
          $allowedBranches = @('main', 'release/*')
          $skipBranchCheck = '${{ github.event.inputs.skip_branch_check }}' -eq 'true'
          
          # Check if release is from an allowed branch
          $shouldProcess = $false
          if ($skipBranchCheck) {
            Write-Host "Branch check skipped by user input"
            $shouldProcess = $true
          } else {
            foreach ($pattern in $allowedBranches) {
              if ($targetCommitish -like $pattern) {
                Write-Host "âœ“ Release is from allowed branch: $targetCommitish"
                $shouldProcess = $true
                break
              }
            }
            
            if (-not $shouldProcess) {
              Write-Warning "Release is from branch '$targetCommitish' which is not in the allowed list: $($allowedBranches -join ', ')"
              Write-Host "Skipping runtime package generation for this release."
              Write-Host "To process this release anyway, manually trigger this workflow with 'Skip branch check' enabled."
            }
          }
          
          # Use multiline format to avoid escaping issues
          "tag=$tag" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "releaseId=$releaseId" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "shouldProcess=$shouldProcess" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
          "targetCommitish=$targetCommitish" | Out-File -FilePath $env:GITHUB_OUTPUT -Encoding utf8 -Append
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Download Release Assets
        if: steps.release.outputs.shouldProcess == 'true'
        run: |
          $tag = '${{ steps.release.outputs.tag }}'
          Write-Host "Downloading release assets for tag: $tag"
          
          # Create temp directory for downloads
          $downloadPath = Join-Path $env:TEMP "release-apps-$tag"
          New-Item -ItemType Directory -Path $downloadPath -Force | Out-Null
          
          # Download all *-Apps-*.zip files from the release
          gh release download $tag --pattern '*-Apps-*.zip' --dir $downloadPath
          
          # Store the path for next steps
          Add-Content -Path $env:GITHUB_OUTPUT -Value "downloadPath=$downloadPath"
          
          # List downloaded files
          Write-Host "Downloaded files:"
          Get-ChildItem -Path $downloadPath | ForEach-Object { Write-Host "  - $($_.Name)" }
        env:
          GH_TOKEN: ${{ github.token }}
        id: download

      - name: Extract and Generate Runtime Packages
        if: steps.release.outputs.shouldProcess == 'true'
        run: |
          $downloadPath = '${{ steps.download.outputs.downloadPath }}'
          $runtimePath = Join-Path $env:TEMP "runtime-packages"
          New-Item -ItemType Directory -Path $runtimePath -Force | Out-Null
          
          Write-Host "Processing downloaded app packages..."
          
          # Get all zip files
          $zipFiles = Get-ChildItem -Path $downloadPath -Filter "*.zip"
          
          foreach ($zipFile in $zipFiles) {
            Write-Host "`nProcessing: $($zipFile.Name)"
            
            # Extract zip
            $extractPath = Join-Path $downloadPath $zipFile.BaseName
            Expand-Archive -Path $zipFile.FullName -DestinationPath $extractPath -Force
            
            # Find all .app files
            $appFiles = Get-ChildItem -Path $extractPath -Filter "*.app" -Recurse
            
            Write-Host "  Found $($appFiles.Count) app file(s)"
            
            foreach ($appFile in $appFiles) {
              Write-Host "  Converting: $($appFile.Name)"
              
              try {
                # Import BcContainerHelper if not already loaded
                if (-not (Get-Module -Name BcContainerHelper)) {
                  Import-Module BcContainerHelper -Force
                }
                
                # Extract app info to get name for runtime package
                $appInfo = Get-AppJsonFromAppFile -appFilePath $appFile.FullName
                $runtimeFileName = "$($appInfo.name)_$($appInfo.version)_runtime.app"
                $runtimeFilePath = Join-Path $runtimePath $runtimeFileName
                
                # Create runtime package
                # Note: This creates a copy without source code embedded
                Get-AppRuntimePackage -appFile $appFile.FullName -runtimePackageFile $runtimeFilePath
                
                Write-Host "    Created: $runtimeFileName"
              }
              catch {
                Write-Warning "  Failed to create runtime package for $($appFile.Name): $_"
              }
            }
          }
          
          # Create a zip file with all runtime packages
          $runtimeZipName = ($zipFiles[0].BaseName -replace '-Apps-', '-Apps-Runtime-') + '.zip'
          $runtimeZipPath = Join-Path $downloadPath $runtimeZipName
          
          if ((Get-ChildItem -Path $runtimePath -Filter "*.app").Count -gt 0) {
            Compress-Archive -Path "$runtimePath\*.app" -DestinationPath $runtimeZipPath
            Write-Host "`nCreated runtime package archive: $runtimeZipName"
            
            Add-Content -Path $env:GITHUB_OUTPUT -Value "runtimeZipPath=$runtimeZipPath"
            Add-Content -Path $env:GITHUB_OUTPUT -Value "runtimeZipName=$runtimeZipName"
            Add-Content -Path $env:GITHUB_OUTPUT -Value "hasRuntimePackages=true"
          }
          else {
            Write-Warning "No runtime packages were created"
            Add-Content -Path $env:GITHUB_OUTPUT -Value "hasRuntimePackages=false"
          }
        id: generate

      - name: Upload Runtime Packages to Release
        if: steps.release.outputs.shouldProcess == 'true' && steps.generate.outputs.hasRuntimePackages == 'true'
        run: |
          $runtimeZipPath = '${{ steps.generate.outputs.runtimeZipPath }}'
          $tag = '${{ steps.release.outputs.tag }}'
          
          Write-Host "Uploading runtime packages to release $tag..."
          
          gh release upload $tag $runtimeZipPath --clobber
          
          Write-Host "Successfully uploaded runtime packages!"
        env:
          GH_TOKEN: ${{ github.token }}

      - name: Add Comment to Release
        if: steps.release.outputs.shouldProcess == 'true' && steps.generate.outputs.hasRuntimePackages == 'true'
        uses: actions/github-script@v7
        with:
          github-token: ${{ github.token }}
          script: |
            const releaseId = '${{ steps.release.outputs.releaseId }}';
            const runtimeZipName = '${{ steps.generate.outputs.runtimeZipName }}';
            
            // Get current release
            const { data: release } = await github.rest.repos.getRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId
            });
            
            // Add note about runtime packages to release body
            const runtimeNote = '\n\n---\n### ðŸ“¦ Runtime Packages\n\nRuntime packages (apps without source code) are available in `' + runtimeZipName + '`.\n\n**Use cases:**\n- Production deployments where source code should not be accessible\n- ISV partners distributing compiled-only versions\n- Compliance requirements restricting source code distribution';
            
            const updatedBody = release.body + runtimeNote;
            
            await github.rest.repos.updateRelease({
              owner: context.repo.owner,
              repo: context.repo.repo,
              release_id: releaseId,
              body: updatedBody
            });
            
            console.log('Added runtime package information to release notes');
